#! /usr/bin/env ruby

require 'orogen'
require 'optparse'

verbosity = 0
extended_states = false
parser = OptionParser.new do |opt|
    opt.banner = "Usage: orogen [options] <template file>"

    opt.on("--[no-]corba", "enables/disables corba support [disabled]") do |flag|
        if flag then Orocos::Generation.enable_corba
        else Orocos::Generation.disable_corba
        end
    end
    opt.on("--extended-states", "enable extended states for all tasks defined in this project") do |flag|
        extended_states = true
    end

    opt.on("--target=TARGET", "set the orocos build target (gnulinux or xenomai)") do |target|
        target = target.to_s
        if target !~ /^(gnulinux|xenomai)$/
            STDERR.puts "unknown target '#{target}', possible values are gnulinux and xenomai"
            exit 1
        end

        Orocos::Generation.orocos_target = target.to_s
    end

    opt.on("-v", "--verbose") { Orocos::Generation.logger.level = Logger::INFO; verbosity = 1 }
    opt.on("-d", "--debug")   { Orocos::Generation.logger.level = Logger::DEBUG; verbosity = 2 }
    opt.on("-h", "--help", "this help message") do
        puts opt
        exit 0
    end
    opt.separator ""
    opt.on("--really-clean", "removes all autogenerated files, and user-side part that are identical to the templates") do
        Orocos::Generation.really_clean
        exit 0
    end
    opt.on("--clean", "removes all autogenerated files") do
        Orocos::Generation.clean
        exit 0
    end
    opt.on("--base-dir", "the directory where orogen lib part is installed") do
        puts Orocos::Generation.base_dir
        exit 0
    end

    opt.on("-V", "--version", "displays the current orogen version") do
        puts "orogen v#{Orocos::Generation::VERSION}"
        puts "Copyright 2008-2010 DFKI"
        STDOUT.flush
    end
end
files = parser.parse! ARGV
if files.size != 1
    puts parser
    exit 1
end

ConfigError = Orocos::Generation::ConfigError
begin
    filename  = files.first
    component = 
        begin
            component = Orocos::Generation::Component.new
            component.extended_states = extended_states
            component.load(filename)

        rescue Exception => e
            # Two options:
            #  * the first line of the backtrace is the orogen file
            #    => change it into a ConfigError. If, in addition, this is a
            #       NoMethodError then change it into a statement error
            #  * the second line of the backtrace is in the orogen file
            #    => most likely a bad argument, transform it into a ConfigError
            #       too
            #  * all other cases are reported as internal errors
            file_pattern = /#{Regexp.quote(File.basename(filename))}/
            if e.backtrace.first =~ file_pattern
                if e.kind_of?(NoMethodError) || e.kind_of?(NameError)
                    e.message =~ /undefined (?:local variable or )?method `([^']+)'/
                    method_name = $1
                    raise ConfigError, "unknown statement '#{method_name}'", e.backtrace
                else
                    raise ConfigError, e.message, e.backtrace
                end
            elsif (e.backtrace[1] =~ file_pattern) || e.kind_of?(ArgumentError)
                raise ConfigError, e.message, e.backtrace
            end
            raise
        end

    component.generate
rescue Orocos::Generation::ConfigError => e
    raise if verbosity > 0
    # Find the first stack frame on the orogen file
    error_line = e.backtrace.find { |line| line =~ file_pattern }
    STDERR.puts "#{error_line}: #{e.message}"
    exit 1
rescue Exception => e
    STDERR.puts "===== Internal error ======="
    STDERR.puts "Please report the following error to the orogen developpers"
    raise
end

